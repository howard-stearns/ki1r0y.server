"use strict";
/*jslint browser: true, devel: true, vars: true, forin: true, plusplus: true, continue: true */
// Copyright (c) 2013 Beyond My Wall. All rights reserved until we get a clue.
// This is a good place to start in figuring out how things work.

// Kilroy Coding Lexicon (e.g., variable names):
//
// user: a Facebook user
// object: an item or assembly in one or more scenes, used as a selection or destination. Also called a 'thing'.
// place: a mutable object (All other objects are immutable.)
// scene: a toplevel place; the root of a scene-graph
// media: a file containing an immutable image, video, audio, mesh, or animation
//
// nametag: a human-readable name string, possibly containing spaces
// idtag: a globally unique string identifying an object, user, or media
// idvtag: an idtag identifying a specific (immutable) version of a place (idtag == idvtag for immutable objects)
// timestamp: a javascript Date.getTime value. Versions are identified by timestamp, and place definitions map timestamps to idvtags.
//
// The above are used as compound names, as in userIdtag, sceneIdvtag, objectNametag.
// N.B.: We use idtag value as the Unity 'name' instance variable value, so that Unity Find(idtag) works.

var SCENE, THING, USER, InitialTitle;
var sceneReady, sayOnce, clearOnce, sendUnity, showSocial, updateLinksStyles, softLink, softJump, kilroyMime, logEvent, _;

// The rules are:
// * URL paths can be of the form /places/sceneIdtag or /things/objectIdtag.
//   - The latter form, without parameters, show a listing of scenes that use the object rather than directly to a scene.
//   - To be in a particular scene, the URL must be either the first form or have an fb_ref parameter.
// * A URL can have an &fb_ref=<ref> parameter, where <ref> is of the form insightLabel__sceneIdtag:
//   1. FB "insights" and other traffic analyzers can use insightLabel to identify traffic sources. 
//      (Insights says there must be no more than 500 unique insightLabel values each week.)
//      Our cannonical insightLabel is 'public', but we swap it out for 'email', 'like', or 'comments',
//      so that we/insights can tell whether entry was from email, a user-story generated by a like button, etc.
//   2. Our server uses sceneIdtag to takes us directly to the right scene, setting the SCENE.idtag global in the html.
//   FB requires the whole ref string to be less than 50 chars (e.g., ('comments_' + aGUID).length < 50).
// * The href attribute of FB social plugins (buttons such as Like/Comment/etc) must not directly include the ref.
//   This is so that the object URL is the same for the same object in different scenes, so that they share
//   social metadata. Instead, some plugins accept a sparate 'ref' attribute. When FB creates a user-story 
//   (e.g., in a timeline), it concatenates ?fb_ref=ref onto the (non-scene-specific) href url of the button.
//   The html produced by our /places and /things URLs has several social media buttons, with the ref attribute set.
//   [Alas, FB doesn't always add fb_ref in its links, in which case following the link gives a scene listing.
//    On 4/15/13 following a Like on a timeline gives me:
//    http://beyondmywall.fe100.net/object/e6b5f3fdc3aec5c0e4dad7b4a56f7460fc84d517
//      ?fb_action_ids=164707137024869&fb_action_types=og.likes&fb_ref=like__G1&fb_source=other_multiline
//      &action_object_map=%7B%22164707137024869%22%3A290961634369611%7D&action_type_map=%7B%22164707137024869%22%3A%22og.likes%22%7D
//      &action_ref_map=%7B%22164707137024869%22%3A%22like__G1%22%7D
//    This action map stuff is apparently: fb_action_ids: '164707137024869', action_ref_map: '{"164707137024869":"like__G1"}', etc.
//    Following a link from a Comment on a timeline gives me:
//    http://beyondmywall.fe100.net/object/e6b5f3fdc3aec5c0e4dad7b4a56f7460fc84d517?fb_comment_id=fbc_290961634369611_1291122_290998267699281#fe4ba2e08]
// * Our urls can also include a version parameter. Scene version are specified in URLs with a timestamp rather
//   than an explicit idvtag. (E.g., /places/sceneIdtag?version=1368993677170) Old versions can disappear (either
//   by user action or our own thinning of older version trees), and when that happens, the old timestamp will
//   also disappear. We'd like for a request to get the version in place at the requested time (e.g., the next
//   oldest version we have before the one requested), and we can't do that for missing stuff unless the request
//   is made by timestamp. (Because idvtags are unsequenced hashes.) As a side benefit, people can request
//   any timestamp, without knowing what versions are available.  The version parameter should not be included in
//   external communications (email bodies, social plugin href), because we always want people to arrive at the
//   "current" version. When people use the back button, we set the current version in the general scene metadata,
//   so that everyone arriving a the current version gets the same version that the current occupants are using.
// * Users can move around to different objects in the scene, and back and forth through time. When
//   they do, we set the browser history state to match. The state explicitly includes properties
//   objectIdtag and sceneIdvtag, and redundantly has a title and url that reflect these.
//   - Visiting an object selects it, so that the new state objectIdtag is that of the object.
//   - Moving away from the object deselects it, and the object is removed from the document.title. 
//     However, we do NOT create a separate history state for this.
//   - Manipulating an object saves the scene, creating a new history state with the new sceneIdvtag,
//     and the objectIdtag of the object that was added/deleted/moved/sized.
//   - Going to a particular state, whether using the browser back/forward buttons, choosing from the
//     the browser history list, or cutting/saving/pasting the url, will load the specified version
//     of the scene and go to the specified object. If the object is not present (e.g., deleted),
//     we go to the center of the scene. (In future versions, we might try to go to the object first,
//     before restoring the scene that had the object removed.) If this is a restoration (e.g.,
//     popping history state), we do not push a new history state; otherwise we do.
// * Browser history state includes a title, path, and app-defined data. It seems that setting the path
//   updates the location.path, but not all browsers update the document.title to match. So when
//   we set the history title, we also explicitly set the document.title to match.

var ScenePrefix = '?fb_ref=public__';
function kilroyURL(sceneIdtag, objectIdtag) {
	var base = location.origin; // Facebook wants absolute URLs everywhere.
	if (!objectIdtag || (objectIdtag === sceneIdtag)) { return base + '/places/' + sceneIdtag; }
	base += '/things/' + objectIdtag;
	return sceneIdtag ? base + ScenePrefix + sceneIdtag : base;
}
function peopleURL(idtag) {
	return location.origin + '/people/' + idtag;
}
function thumbnailURL(idvtag) {
	return location.origin + '/thumb/' + idvtag + '.png';
}
function addTimestamp(url, timestamp) {
	return url + (_.contains(url, '?') ? '&' : '?') + 'version=' + timestamp;
}
function removeChildren(node) {
	while (node.hasChildNodes()) { node.removeChild(node.lastChild); }
}

window.onpopstate = function (event) {
	console.log('onpopstate state:', event.state, 'SCENE.nametag:', SCENE.nametag, 'SCENE.timestamp:', SCENE.timestamp, 'location:', location);
	if (!event.state && !SCENE.nametag) { return; } // webkit (safari/chrome) calls with null values on startup.
	var state = event.state;
	if (state) {
		document.title = state.title;
		// FIXME: combine this with softJump
		if (state.timestamp && (state.timestamp !== SCENE.timestamp)) {
			var spec = state.objectPath
				? state.timestamp + ':' + state.objectPath
				: state.timestamp + ':' + SCENE.idtag + ':' + state.objectIdtag;
			sendUnity('Avatar', 'RestoreSceneBack', spec);
		} else {
			sendUnity('Avatar', 'GoBackTo', state.objectPath || state.objectIdtag);
		}
	} else {   //- Popping back to first entry. Let's hope the location.href is right.
		softJump(location.pathname, location.search, 'GoBackTo');
		document.title = document.getElementById('ogTitle').getAttribute('content'); // not set by GoBackTo, so grab from element
	}
	clearOnce('undo');
};

// Create search/history result row from object d. Expected properties are:
// timestamp, idvtag (which can be for scene or object, but must correspond to timestamp), 
// sceneNametag, sceneIdtag, 
// optional objectNametag, objectIdtag
// and either action (if history) or userIdtag (if search)
function resultRow(d, isHistory) {
	//console.log('resultRow', (isHistory ? 'history' : 'search'), d);
	var row = document.createElement('tr');
	var makeElt = function (tag, attributes, optionalContents) {
		var attribute, val, elt = document.createElement(tag);
		for (attribute in attributes) {
			val = attributes[attribute];
			if (val === undefined) { continue; }
			if (attribute.match(/^on.*/)) {
				elt[attribute] = val; // because that's how it works
			} else {
				elt.setAttribute(attribute, val);
			}
		}
		if (optionalContents) {
			elt.appendChild(typeof optionalContents === 'string'
							? document.createTextNode(optionalContents)
							: optionalContents);
		}
		return elt;
	};
	var addCell = function (tag, attributes, optionalContents, optionalCustomKey) {
		var td = document.createElement('td'), elt = makeElt(tag, attributes, optionalContents);
		if (optionalCustomKey) { td.setAttribute('sorttable_customkey', optionalCustomKey); }
		td.appendChild(elt);
		row.appendChild(td);
		return elt;
	};
	var addThumbnail = function (name, url, thumb, description, sceneExtension) {
		var title = 'Show social information without visiting.';
		if (description) { title += ' ' + description; }
		return addCell('img', {
			src: thumb,
			height: '50px',
			draggable: true,
			onclick: function () { showSocial(name, url, description, sceneExtension && (url + sceneExtension)); },
			ondragstart: function (e) { e.dataTransfer.setData(kilroyMime, url); },
			title: title
		});
	};
	var addLink = function (name, url, qualifier, optionalObjectPath) {
		return url ? addCell('a', {
			class: "kilroyLink",
			href: url,
			title: 'Visit ' + name + (qualifier || '') + '.',
			kilroyObjectPath: optionalObjectPath,
			onclick: softLink
		}, name) : addCell('span', {}, name);
	};
	if (typeof d.timestamp === 'string') { d.timestamp = parseInt(d.timestamp, 10); }
	var sceneURL = kilroyURL(d.sceneIdtag), objectURL = sceneURL;
	if (d.objectNametag) {
		objectURL = kilroyURL(d.sceneIdtag, d.objectIdtag);
		var genericObjectURL = kilroyURL(null, d.objectIdtag); // without scene. But I can't remember why!
		addThumbnail(d.objectNametag, genericObjectURL, thumbnailURL(d.idvtag), d.description, ScenePrefix + d.sceneIdtag);
	} else {
		addThumbnail(d.sceneNametag, sceneURL, thumbnailURL(d.idvtag), d.description);
	}
	addLink(d.objectNametag || '', kilroyURL(d.sceneIdtag, d.objectIdtag), ' in ' + d.sceneNametag, d.objectPath);
	addLink(d.sceneNametag, sceneURL);
	var dd = new Date(d.timestamp);
	var ddString = dd.toLocaleString();
	if (isHistory) {
		addLink('', addTimestamp(objectURL, d.timestamp), d.sceneNametag + ' and wind it back to this time', d.objectPath).innerHTML = ddString;
	} else {
		addCell('span', {title: 'Last change.'}, ddString);
	}
	if (isHistory) {
		addLink(d.action);
	} else {
		addThumbnail('<fb:name uid="' + d.userIdtag + '" linked="false"/>',
					 peopleURL(d.userIdtag),
					 'http://graph.facebook.com/' + d.userIdtag + '/picture',
					 d.description);
	}
	return row;
}
// Add d object as the last resultRow in the "related" (search) table.
function addToRelatedTableDirectly(elt) { document.getElementById('relatedBody').appendChild(elt); }
function addToRelatedTable(d) { addToRelatedTableDirectly(resultRow(d)); }
function setRelated(data) { // Data is an array of objects suitable for resultRow().
	removeChildren(document.getElementById('relatedBody'));
	if (typeof data === 'string') { // from plugin or initial
		data = JSON.parse(data); console.log('plugin/initial =>: setRelated', data);
	} else if (data && data.length) { // from search 
		logEvent('discovery', 'related', '', data.length); // FIXME: too many of these.
		data.forEach(addToRelatedTable);
	} else {
		addToRelatedTableDirectly(document.createTextNode('No current results'));
	}
	updateLinksStyles();
}
// Add properties as the first (most recent) resultRow in the histor table.
function addToHistoryTable(objectIdtag, timestamp, nametag, action, idvtag, objectPath) {
	// It's handy to be able to pass scene info explicitly if we know, otherwise:
	var sceneIdtag = SCENE.idtag;
	var sceneNametag = SCENE.nametag;
	var tbody = document.getElementById('historyBody');
	var data = {timestamp: timestamp, action: action, sceneNametag: sceneNametag, sceneIdtag: sceneIdtag, idvtag: idvtag, objectPath: objectPath};
	if (objectIdtag !== sceneIdtag) {   // no object data for scenes
		data.objectIdtag = objectIdtag;
		data.objectNametag = nametag;
	}
	tbody.insertBefore(resultRow(data, true), tbody.firstChild);
}
// Add properties to both browser history and the history table.
function addHistory(objectIdtag, timestamp, nametag, action, idvtag, suppressMessage, objectPath) {
	//console.log('addHistory', objectIdtag, timestamp, nametag, action, idvtag, suppressMessage);
	var scenePath = kilroyURL(SCENE.idtag, objectIdtag);
	var path = addTimestamp(scenePath, timestamp);
	var title = action ? action + ' ' : '';
	var name = nametag || SCENE.nametag;	
	title += name;
	var state = {objectIdtag: objectIdtag, timestamp: timestamp, title: name, objectPath: objectPath};
	if (!suppressMessage) {
		sayOnce('You can use the browser back button to "undo".', 'undo');
	}
	// The third (url) argument to pushState is optional, but if we don't include it:
	// 1. Browser histories that show entries only url will just have the last state.
	// 2. Cut+paste of browser url won't get us back to "here".
	document.title = name;
	history.pushState(state, title, path); // some browser might present useful distinctions for title. Others will force matching of document.title.
	addToHistoryTable(objectIdtag, timestamp, nametag, action || 'go', idvtag, objectPath);
}
// We don't know whether addPendingHistory or historyData will be called first.
// historyData sets the initial (past session) history, while addPendingHistory actually commits it,
// which can't be done until the scene is ready and SCENE_mumble/OBJECT_mumble globals are set.
var pendingHistory = null;
function addPendingHistory() {
    console.log('FIXME addPendingHistory pending:', pendingHistory, 'user:', peopleURL(USER.idtag), 'author:', document.getElementById('sceneUserNametag').href);
	if (!pendingHistory) { return; } // not ready to do this yet.
	if (peopleURL(USER.idtag) !== document.getElementById('sceneUserNametag').href) { // don't show history of other people's scenes.
		pendingHistory = null;
		return;
	}
	// When jumping from one scene to another (e.g., from search results),
	// we will receive the history of the new scene, and we could add it to the history
	// here. Right now we do not. The thinking is that if someone starts a session
	// (e.g., following a link from some external page or app), it's nice to give
	// them the history of the place they were, giving people a nice cozy sense
	// of being able to undo things. But from that point on in the session, it 
	// should really just what the user does now, rather than inserting historical things
	// into between stuff that the user did this session. Note that the user can always
	// reload mid-session, which has the effect of starting a new session with a new browser
	// history, and thus getting the older-session history for the current scene.
	if (window.history.state) { return; }

	var timestamps = Object.keys(pendingHistory), tIndex = 0;
	timestamps.sort();
	// Do this asynchronously so as to not slow the user down.
	var doNextTimestamp = function () {
		if (tIndex >= timestamps.length) { // all done
			updateLinksStyles();
			pendingHistory = null;
		} else {
			var timestamp = timestamps[tIndex++];
			var idvtag = pendingHistory[timestamp];
			var now = idvtag === SCENE.idvtag;
			var idtag = now ? THING.idtag || SCENE.idtag : SCENE.idtag;
			var isNowObject = now && THING.idtag && ((THING.idtag !== SCENE.idtag) || (THING.idtag.length !== 27));
			var nametag = now ? THING.nametag : '';
			//console.log('adding', timestamp, idvtag, now, idtag, nametag, isNowObject, THING.idtag, SCENE.idtag, tIndex, 'of', timestamps.length);
			addHistory(idtag, timestamp, nametag,
					   now ? 'entry' : 'older',
					   isNowObject ? idtag : idvtag,
					   'no message');
			setTimeout(doNextTimestamp, 20);
		}
	};
	doNextTimestamp();
}
function historyData(json) { // from plugin
	if (location.pathname.match(/\/people/)) { return; } // No initial history for people, only scenes
	pendingHistory = JSON.parse(json);
    console.log('FIXME historyData', pendingHistory);
	if (SCENE.nametag) { addPendingHistory(); }
}
